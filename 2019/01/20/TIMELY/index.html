<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="congestion control,RDMA,datacenter transport," />










<meta name="description" content="here for paper    Author: Radhika Mittal  (UC Berkeley)     datacenter transport,delay-based congestion control; os-bypass; RDMA">
<meta name="keywords" content="congestion control,RDMA,datacenter transport">
<meta property="og:type" content="article">
<meta property="og:title" content="TIMELY">
<meta property="og:url" content="http://yoursite.com/2019/01/20/TIMELY/index.html">
<meta property="og:site_name" content="miqianmimi Ma">
<meta property="og:description" content="here for paper    Author: Radhika Mittal  (UC Berkeley)     datacenter transport,delay-based congestion control; os-bypass; RDMA">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图1.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图2.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图3.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图4.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图5.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图6.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图7.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/公式1.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/算式1.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/算法1.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图8.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/公式2.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/公式3.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图9.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图10.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图11.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图12.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/表1.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图13.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图14.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图15.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图16.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图17.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图19.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图20.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图21.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图22.png">
<meta property="og:image" content="http://yoursite.com/2019/01/20/TIMELY/图23.png">
<meta property="og:updated_time" content="2019-01-25T15:46:38.425Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TIMELY">
<meta name="twitter:description" content="here for paper    Author: Radhika Mittal  (UC Berkeley)     datacenter transport,delay-based congestion control; os-bypass; RDMA">
<meta name="twitter:image" content="http://yoursite.com/2019/01/20/TIMELY/图1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/20/TIMELY/"/>





  <title>TIMELY | miqianmimi Ma</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b23a977420dff14ebc585ce07adca932";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">miqianmimi Ma</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/20/TIMELY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YiqingMa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="miqianmimi Ma">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">TIMELY</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-20T15:47:35+08:00">
                2019-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/paper/" itemprop="url" rel="index">
                    <span itemprop="name">paper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/20/TIMELY/" class="leancloud_visitors" data-flag-title="TIMELY">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">Readers <i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>人
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p style="color:MediumSeaGreen;font-size:16px;font-family:Comic Sans MS">  <a id="download" href="https://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p537.pdf" target="_blank" rel="noopener"><i class="fa fa-pencil fa-lg"></i><span>here for paper</span></a> </p>

<ul>
<li>Author: <code>Radhika Mittal</code>  (UC Berkeley)</li>
<li><p style="color:MediumSeaGreen;font-size:16px;font-family:Comic Sans MS">    datacenter transport,delay-based congestion control; os-bypass; RDMA </p>

</li>
</ul>
<hr>
<a id="more"></a>
<h2 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h2><p>数据中心协议要求降低网络延迟，提升带宽。在本文中，作者选择了最简单的测量方式——RTT作为拥塞控制的指标。首先，作者表明新一代NIC，可以做到微妙精度的RTT测量，并且，作者证明了RTT信号与网络队列的强相关性。然后作者提出了<strong>TIMELY(Transport Informed by MEasurement of LatencY)</strong>，描述了如何通过RTT梯度来控制数据包传输速率，确保在提供高带宽的同时保证较低的延迟。作者在具有OS-bypass功能的NIC上运行的主机端软件中实现这一设计。也在Clos网络拓扑上，使用数百台计算机做实验，证明了其出色性能。TIMELY是第一个用于数据中心的基于延迟的拥塞控制协议，相比早起基于延迟的方案Vegas，TIMELY的RTT信号少一个级别，但是它能达到更好的效果。</p>
<blockquote>
<p>关键词：数据中心传输协议，基于延迟的拥塞控制，OS-bypass(操作系统旁路），RDMA</p>
</blockquote>
<hr>
<h2 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h2><p>在数据中心网络中，理想的拥塞信号有以下的属性:</p>
<ol>
<li>将拥塞程度的信息，迅速通知发件器</li>
<li>具有足够辨识力，在多流的复杂环境中运行</li>
<li>部署起来相对容易</li>
</ol>
<p>现有的以延迟作为指标的系统有以下问题：</p>
<ol>
<li>基于延迟的方案，与某些基于丢包的方案竞争带宽时，表现不佳。</li>
<li>由于主机和网络原因，延迟估计可能不准确，难以用微妙精度测量。</li>
</ol>
<p>作者观察到最新的NIC允许RTT精细度的测量：</p>
<ol>
<li>最新的NIC可以高精度地标出时间戳</li>
<li>硬件生成ACK支持自动消除主机响应时间</li>
<li>数据中心软件可避免不同传输协议的流竞争</li>
</ol>
<p>因此，在这样的大环境下，作者提出了基于延迟的拥塞控制TIMELY。TIMELY这一机制在数据中心显示出优异的性能。</p>
<hr>
<h2 id="数据中心拥塞指标RTT的值："><a href="#数据中心拥塞指标RTT的值：" class="headerlink" title="数据中心拥塞指标RTT的值："></a>数据中心拥塞指标RTT的值：</h2><p>现有数据中心协议，大多使用交换机上的信息作为拥塞程度的指标，作者认为RTT延迟时间，是一个更优越的拥塞指标，可以不需要交换机信息。</p>
<h3 id="RTT直接反应延迟"><a href="#RTT直接反应延迟" class="headerlink" title="RTT直接反应延迟"></a>RTT直接反应延迟</h3><p>作者将RTT与ECN标记做了简单的对比，描述了RTT作为拥塞控制指标的优势：</p>
<p>（一）RTT直接测量了因为队列堆积引起的端到端延迟时间，而ECN无法直接得到这个延迟时间。</p>
<p>（二）ECN标记仅表示包的队列占用超过了一定的阈值。在以下情况下，ECN不能很好的反应拥塞情况——具有不同优先级的多个流共享同一个链路，低优先级流可能经历较大的队列延迟时间，但它的队列占用并不一定很大（不满足ECN标记的条件）</p>
<p>（三）ECN标记描述单一交换机的行为，但拥塞可能发生在多个交换机上，ECN标记并不能很好地分清楚他们。</p>
<p>（四）RTT甚至适用于支持FCoE的无损网络结构。在这种结构下，由于确保零丢包的PFC机制，使得队列占用无法反映拥塞情况。</p>
<h3 id="RTT可以被精确测量"><a href="#RTT可以被精确测量" class="headerlink" title="RTT可以被精确测量"></a>RTT可以被精确测量</h3><p>一个最重要的问题是：RTT在数据中心中，是否能够被准确测量？因为数据中心的RTT，相比其他网络延迟，要小1000倍。</p>
<p>新一代NIC从硬件上保证了，可以准确记录包传输和接收时间，且不受软件的影响，这使得精确地追踪端到端网络延迟成为可能。</p>
<p>以下是一组对比实验，证明NIC相比TCP内核能够更精确地测量RTT的值。作者使用10Gbps的链路将两台主机连接到同一网络，并且发送16KB的消息。由于网络中没有拥塞，希望RTT测量值较低且较稳定。</p>
<p>图1比较了使用NIC的时间戳，测量到的RTT的CDF，以及通过OS的TCP协议栈，测量到的RTT的CDF。使用NIC时间戳测得的RTT的CDF（概率累积分布函数）几乎是一条直线，这说明方差很小。而由内核TCP测得的RTT的CDF，方差偏大。</p>
<p><img src="/2019/01/20/TIMELY/图1.png" alt=""></p>
<blockquote>
<p>说明NIC上测量的RTT相比自带的TCP测量的要精准许多；</p>
</blockquote>
<h3 id="RTT-是一个快速、多位信号："><a href="#RTT-是一个快速、多位信号：" class="headerlink" title="RTT 是一个快速、多位信号："></a>RTT 是一个快速、多位信号：</h3><p>作者先说明了，网络中的队列延迟的具体计算方式，通过从总的RTT中减掉固定的传播延迟和序列化延迟，可以得到。</p>
<p>【RTT VS ECN】:<br>ECN作为一个二进制数值（非0即1），因此ECN标记传达的是单个比特的信息，而RTT传达多个比特的信息。（由于每个包都可以携带ECN标记，因此一串ECN标记的序列可以间接表达，多比特的拥塞信息，这是合理的。e.g. DCTCP。）</p>
<p>但ECN这种做法，会破坏标记的独立性，e.g.主机端发生burst时，会使得绝大部分数据包，同时高于或低于标记阈值。</p>
<p>对于RTT而言，测得一个较高的RTT即刻表明网络的拥塞程度。对于网络中burst的情形，测得的延迟是最后那个包的RTT时间，也是整个burst中最大的RTT值。<br><img src="/2019/01/20/TIMELY/图2.png" alt=""><br>作者模拟了incast的实验，图2测得的RTT的CDF，以及在交换机上测量的队列占用的CDF，从实验结果看出，这两个概率累积函数非常匹配。</p>
<p>其实，ECN信号与RTT并不强相关。通过类似的实验，作者得到图3所示的散点图和方框图，其显示了ECN标记和RTT之间的弱相关性。<br><img src="/2019/01/20/TIMELY/图3.png" alt=""></p>
<h3 id="RTT-的限制："><a href="#RTT-的限制：" class="headerlink" title="RTT 的限制："></a>RTT 的限制：</h3><p>作者发现RTT在有一定的局限性：——RTT测量可以分为两部分，正向路径和反向路径。ACK并不能辨别，其经历的是反向路径拥塞，还是正向路径拥塞。一个简单的解决方法是发送具有更高优先级的ACK，以便ACK不会遭遇排队延迟。该方法适用于在同一个方向上发送数据流。</p>
<p>作者进行了一项实验来验证，给ACK设置优先级的效果：作者启动了两个incast（主要和次要），使得主要的与次要的incast共享相同的拥塞队列，如图4所示。<br><img src="/2019/01/20/TIMELY/图4.png" alt=""><br>作者在图5的对比实验中，分析了给ACK设置优先级的情况下延迟的累积分布函数。作者得出的结论是，对ACK划分优先级时，在主要incast下测量的情况，与没有反向拥塞时的情况无法区分。<br><img src="/2019/01/20/TIMELY/图5.png" alt=""></p>
<p>RTT的另一个缺点是，网络路径改变会造成不同的网络延迟。但这一点在数据中心中并不成问题，因为几乎所有路径的传播延迟都很小。</p>
<hr>
<h2 id="TIMELY-结构"><a href="#TIMELY-结构" class="headerlink" title="TIMELY 结构"></a>TIMELY 结构</h2><p>TIMELY的速率控制框架主要由三部分组成，如图6所示。</p>
<ul>
<li>1）用于监控网络拥塞的RTT测量引擎</li>
<li>2）将RTT信号转换为目标发送速率的计算引擎</li>
<li>3）在数据段（包）之间插入延迟间隔，从而实现目标速率的控制引擎<br><img src="/2019/01/20/TIMELY/图6.png" alt=""></li>
</ul>
<h3 id="RTT的测量"><a href="#RTT的测量" class="headerlink" title="RTT的测量"></a>RTT的测量</h3><p>根据图7，作者定义了RTT的测量方式——将多个数据包组成的busrt，作为一个完整的单位，从发送第一个数据包tsend至接收到ACK tcompletion的时间被定义为整个burst的完成时间。</p>
<p>总延迟，通常由以下几部分组成：</p>
<ul>
<li>1）传输中所有数据包段的序列化延迟，通常高达64 KB。</li>
<li>2）传输数据的RTT时间，以及其ACK在数据中心传播的时间。</li>
<li>3）接收器生成ACK的时间。</li>
<li>4）正反两个方向上的交换机队列延迟时间<br><img src="/2019/01/20/TIMELY/图7.png" alt=""><br>这几部分的时间分别可以通过以下方式处理：</li>
</ul>
<p>第一部分，可以由段的大小和NIC的线速率决定，可以从总时间中减去。<br>第二部分，传播延迟时间，它又被称作最小RTT，并且对于给定流，数值是固定的，也可以减去。<br>第三部分，因为采用基于NIC的ACK，所以这个值足够接近零，可以忽略。<br><code>第四部分</code>，队列延迟时间，也是导致了RTT变化的原因，这是我们检测拥塞的重点对象。</p>
<p>TIMELY将RTT，如下定义：<br><img src="/2019/01/20/TIMELY/公式1.png" alt=""></p>
<blockquote>
<p>此外，还需注意以下指标：<br>（1）<code>ACK的时间戳</code>，由NIC提供，这一完成时间戳指标 <code>tcompletion</code>。因为由OS提供的时间戳受到诸如调度和中断之类的变化的影响不精确，所以采用了NIC提供的时间戳指标。</p>
</blockquote>
<blockquote>
<p>（2）<code>tsend</code>是在将一段数据传输到NIC之前，由读取产生的时间。</p>
</blockquote>
<blockquote>
<p>（3）<code>ACK的生成</code> 采用基于NIC生成ACK，以便我们可以忽略接收器的周转时间。</p>
</blockquote>
<h3 id="速率计算引擎"><a href="#速率计算引擎" class="headerlink" title="速率计算引擎"></a>速率计算引擎</h3><p>该组件实现了基于RTT的拥塞控制算法，详见§4。速率计算引擎的接口很简单。RTT测量引擎以微秒为单位向速率计算引擎提供RTT，这是仅有的输入，附加的一些时间信息也可能有一定用处。</p>
<h3 id="速率控制引擎"><a href="#速率控制引擎" class="headerlink" title="速率控制引擎"></a>速率控制引擎</h3><p>​速率控制引擎将消息分成若干段后进行传输，并依次将每个段发送到调度程序。调度程序通过段大小，流速（由速率计算引擎提供）和最后一个包的传输时间，来计算当前段的发送时间，并将该段放入调度程序中的优先级队列中。调度程序会计算在两个这样的段之间，插入多少调步延迟（pacing delay）。</p>
<p><code>段落总结</code>：TIMELY是基于速率而不是基于窗口的，它可以更好地控制burst的情形。因为，在数据中心，少量包裹burst的情况下，调整发送窗口不能够提供对数据包传输的细粒度控制。但通过指定目标速率，可以很容易控制burst的时间间隔。</p>
<hr>
<h2 id="TIMELY-拥塞控制"><a href="#TIMELY-拥塞控制" class="headerlink" title="TIMELY 拥塞控制:"></a>TIMELY 拥塞控制:</h2><p>拥塞控制算法主要在速率计算引擎中实现。本节中，作者<strong>描述实验环境和关键性能指标，以及基于梯度的拥塞控制算法.</strong></p>
<h3 id="度量和设置"><a href="#度量和设置" class="headerlink" title="度量和设置"></a>度量和设置</h3><p>​数据中心网络环境带宽充足，基于经常出现的burst情形，流的完成时间是最重要的考虑因素，以远程过程调用(Remote Procedure Call)为例。</p>
<ul>
<li>对于较短的RPC，最小完成时间由传播延迟和序列化延迟共同决定。因此，我们尝试最小化队列延迟，来保证较低的RTT。（尾端延迟这一个指标，尤其重要，因为即使一小部分数据包迟到，应用程序的性能也会下降。）这意味，需要满足，低队列延迟和接近零丢包，这两个需求。</li>
<li>对于较长的RPC,由于传输更多数据所需时间更长，所以较长的RPC将具有更长的完成时间，必须保持较高的总吞吐量，以使所有流受益，并保证流之间的公平性。</li>
</ul>
<p>我们评估的主要指标是<code>尾端(第99百分位处)RTT</code>和<code>聚合吞吐量</code>，因为它们共同决定了完成短期和长期RPC的速度快慢。当吞吐量和数据包RTT之间存在冲突时，我们倾向于以牺牲少量带宽来保持较低的RTT。这是因为带宽充足，RTT的增加将直接影响，短RPC的完成时间。次要指标是<code>公平</code>和<code>损失</code>。最后，为了实现可预测的性能，更倾向于稳定的设计，所以更关注于震荡速率，而不是高平均值。</p>
<h3 id="基于延迟梯度的策略"><a href="#基于延迟梯度的策略" class="headerlink" title="基于延迟梯度的策略"></a>基于延迟梯度的策略</h3><p>受到基于延迟的拥塞控制算法，如FAST TCP和Compound和TCP Vegas等开创性工作的启发。<br>TIMELY使用延迟的梯度作为指标，实现拥塞控制。正延迟梯度表示RTT增加，队列堆积；而负梯度表示队列在减少。</p>
<p>作者假设了以下的情形，N台主机同时以y(t)速率给同一条瓶颈链路发送数据，瓶颈链路的处理速率是C，如果主机的发出速率y(t)≤C，作者假定瓶颈链路处的队列延迟是q(t)。如果y(t)&gt;C，那么队列堆积的速度就是(y(t)-C)。那么队列延迟的梯度就是：<br><img src="/2019/01/20/TIMELY/算式1.png" alt=""><br>梯度没有量纲。因此，通过RTT信号测量的延迟梯度可以作为瓶颈链路处的速率不匹配的指标。当队列的大小没有变化时，梯度也为零。TIMELY做的就是希望将流入速率y(t)和处理速率C匹配起来。</p>
<h3 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h3><p>下图显示了拥塞控制算法的核心伪代码。TIMELY对于每个链接，维持了一个单独的速率R(t)，并且使用RTT样本，在每次任务完成后，进行一次更新。它采用梯度追踪，使用平滑的延迟梯度作为误差信号调整速率，以使吞吐量接近可用带宽。此外，使用了阈值，对带宽利用率低或数据包延迟过高，等特殊的情况作出响应。<br><img src="/2019/01/20/TIMELY/算法1.png" alt=""></p>
<p>图8显示了梯度策略以及两个阈值的关系。当RTT处于标准工作范围时，通过梯度跟踪算法来调整发送速率。<br><img src="/2019/01/20/TIMELY/图8.png" alt=""></p>
<h4 id="计算延迟的梯度"><a href="#计算延迟的梯度" class="headerlink" title="计算延迟的梯度"></a><strong>计算延迟的梯度</strong></h4><p>依赖于NIC上的时间戳来计算RTT，并且根据两个连续的RTT样本的差值，来计算延迟梯度。用最小的RTT来做标准化。在实际操作中，最小RTT的值是否精确并不影响最后效果。因此，采用固定值来表示数据中心的传播延迟。最终，把结果输入EWMA过滤器。这个过滤器的作用是可以观察到队列的上升或者下降趋势，同时忽略一些与拥塞无关的队列长度波动。</p>
<h4 id="计算发送速率"><a href="#计算发送速率" class="headerlink" title="计算发送速率"></a><strong>计算发送速率</strong></h4><p>然后，TIMELY使用标准化后的梯度来计算连接目标速率R(t)。如果梯度是负值，这说明网络可以应付总的传入速率，速率有提升的空间。TIMELY在这种情况下，对链接速率做出如下改变R=R+△，其中△是带宽的additive增量常数。如果梯度是正值，这表明发送速率过大，因此TIMELY会采用multiplicative乘法递减，并且用梯度来调整目标速率如下：<br>  <img src="/2019/01/20/TIMELY/公式2.png" alt=""><br>众所周知的AIMD性质保证了算法能获得各链接之间的公平性。</p>
<h4 id="RTT低阈值-Tlow"><a href="#RTT低阈值-Tlow" class="headerlink" title="RTT低阈值-Tlow-"></a><strong>RTT低阈值-Tlow-</strong></h4><p>​在实际操作中，TIMELY的速率控制策略在&lt;=64KB的段上执行，较大的段会导致burst，产生短暂的队列堆积，并导致RTT突然增加到峰值，核心算法检测到后，较大的正延迟梯度会指示拥塞，极大得减少发送速率。而这种行为没有必要。因此，可通过设置一个Tlow，RTT低阈值，来过滤RTT的突增情况。对于大于这个阈值的RTT样本，才开始使用延迟梯度调整速率的策略。</p>
<h4 id="RTT高阈值-Thigh"><a href="#RTT高阈值-Thigh" class="headerlink" title="RTT高阈值-Thigh-"></a><strong>RTT高阈值-Thigh-</strong></h4><p>梯度算法的预期是能够在，保持接近瓶颈链路吞吐量的情况下，构建很低的队列。然而理论上存在一种情况，队列占用很大，但是维持不变，在这种情况下，梯度也保持为零。为了避免这种情况，Thigh作为一个端到端网络队列延迟的可容忍的上限，它通过一种与梯度无关的方式来降低速率，这是一种保护操作。如果测出的RTT高于Thigh，则按照如下公式降低速率：<br><img src="/2019/01/20/TIMELY/公式3.png" alt=""><br>注意到，公式中使用的是瞬时而不是平滑的RTT。这么做，可以减缓对单个过大的RTT的响应速度，因为它优先是要保证低延迟和避免包丢失。</p>
<h4 id="激进增加HAI-Hyperactive-increase-为了更快的收敛"><a href="#激进增加HAI-Hyperactive-increase-为了更快的收敛" class="headerlink" title="激进增加HAI(Hyperactive increase)为了更快的收敛"></a><strong>激进增加HAI(Hyperactive increase)为了更快的收敛</strong></h4><p>因为受到TCP BIC，CUBIC以及QCN启发，作者在TIMELY中，实现了HAI选项，为了更快的收敛。它的功能如下：如果TIMELY计算得梯度在几个连续完成时间内均为负值，则HAI启动，速率可以更快的增加，其中rate增加N△而不是△.</p>
<h3 id="梯度-VS-队列大小"><a href="#梯度-VS-队列大小" class="headerlink" title="梯度 VS 队列大小"></a>梯度 VS 队列大小</h3><p>实验具体分析了，基于梯度的策略和基于队列大小的策略不同。如果将Tlow和Thigh的值大小设置为相同的，那么TIMELY的拥塞控制将退化为基于队列大小的策略，类似TCP FAST 算法。Ttarget是唯一的RTT阈值，这一数值加性增加，乘性递减。（additively increased, multiplicately decreased）</p>
<hr>
<p>图9中比较了基于梯度和基于队列大小，这两种不通过策略下，处理incast流时的带宽和延迟的性能好坏。可以看到，基于队列大小的方法可以维持低延迟，或者高带宽，但很难同时满足两者。（建立一个RTT阈值较高的standing queue，带宽可以达到最大化，然而延迟就会受损；相反的，建立一个RTT阈值较低的standing queue，延迟可以最优，但带宽就不能得到保证，因为队列经常是空的）；<code>而基于延迟梯度的算法</code>可以侦测到队列的变化，从而提前预测了拥塞的情况，因此使得这种策略可以在保持网络高带宽利用率的同时，达到较低的尾端延迟水平。<br><img src="/2019/01/20/TIMELY/图9.png" alt=""><br>更进一步来说，如图10中所示，在基于队列大小的策略中，速率的抖动较为严重，因为这种算法要求，根据队列大小，来微调RTT的升降。而基于梯度的算法，在公平保持公平分享带宽的同时，维持了一个较为稳定的速率。<br><img src="/2019/01/20/TIMELY/图10.png" alt=""></p>
<hr>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>实际操作中，作者使用10Gbps的支持OS-bypass功能的NIC。该NIC支持多包分段，反馈基于硬件的ACKs以及时间戳，作者运用TIMELY来支持RDMA。下面作者简要描述了，操作中一些值得注意的细节。 </p>
<h3 id="传输界面"><a href="#传输界面" class="headerlink" title="传输界面"></a>传输界面</h3><p>TIMELY只关心传输协议的拥塞控制部分，而不关心应用程序更高级别的接口，这允许协议接口端的设计十分简单：只需要提供消息发送和接收。</p>
<h3 id="使用NIC完成进行RTT的测量"><a href="#使用NIC完成进行RTT的测量" class="headerlink" title="使用NIC完成进行RTT的测量"></a>使用NIC完成进行RTT的测量</h3><p>使用NIC时间戳是十分具有挑战性的事情。NIC只记录绝对时间戳，换句话说，它只记录传输操作的完成时间，需要用户自己记录操作发送到NIC上的时间点。这需要一个机制把主机端的时钟映射到NIC上的时钟，并实现校准。图11对比根据NIC时间戳以及校准机制共同获得的RTTs，以及单纯应用时间戳算出的RTTs的效果。</p>
<p><img src="/2019/01/20/TIMELY/图11.png" alt=""></p>
<p>从图11中看出，使用NIC端的时间戳以及校准机制，测得的结果十分精确。而使用应用端算出的RTTs具有较大的方差，并且较为复杂。</p>
<h3 id="RDMA速率控制"><a href="#RDMA速率控制" class="headerlink" title="RDMA速率控制"></a>RDMA速率控制</h3><p>RDMA的速率控制略有变化。对于RDMA写的操作，发送端的TIMELY直接控制发送间隔。对于RDMA读的操作，接收器处理读的请求，并且对远端主机执行一个数据段的操作。在这种情况下，TIMELY不需要直接控制数据的发送间隔，而是控制Read操作的间隔。</p>
<h3 id="应用限制行为"><a href="#应用限制行为" class="headerlink" title="应用限制行为"></a>应用限制行为</h3><p>考虑如下情况，应用没有足够的数据来使得当前流的传输达到目标速率。这种情况发生时，因为网络没有拥塞，不希望速率控制器，不受限制地增加目标速率。为了防止这种情况，规定，只有应用发送速率达到超过80%的情况下，才增加目标速率，还将最高目标速率限制在10 Gbps。</p>
<h3 id="速率更新频率"><a href="#速率更新频率" class="headerlink" title="速率更新频率"></a>速率更新频率</h3><p>TIMELY的发送速率，确保了在每个RTT间隔中，最多只有一个完成的事件。然而，对于较小的数据段，在一个RTT的时间间隔内，可能会有很多完成的事件。这种情况下，希望根据最新的信息来更新速率。因此，这时采取的是，对每个完成的事件，更新一次速率。</p>
<h3 id="额外的调度机会"><a href="#额外的调度机会" class="headerlink" title="额外的调度机会"></a>额外的调度机会</h3><p>作者尝试用NIC速率限制器，以低于链路速度来传输这一组数据包。基本原理是使用硬件速率限制器，将部分pacing的负荷转移到NIC上。但是因为硬件限制，每间隔几个RTT时间，重新配置发送速率基本不可行。因此作者采用一种混合方法——软件端处理大型的段数据pacing以及硬件端以固定速率(小于链路速率）处理pacing。 NIC做pacing的目的是在两段burst之间插入一些间隙，以此解决多重burst在交换机处重合，导致的延迟突增的问题。</p>
<hr>
<h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>作者在两种不同规模下，评估了TIMELY的效果：</p>
<ul>
<li>在incast设置下，使用小型测试平台，评估了诸多网络基础特性：带宽，公平性， 数据包延迟，以及时间的准确性等microbenchmarks.</li>
<li>在Clos网络拓扑的大规模测试平台中部署TIMELY，所有链路均为10 Gbps。所有实验中的操作系统都是Linux。</li>
</ul>
<p>作者比较了TIMELY与以下两种不同情况作对比：</p>
<ul>
<li>第一种，测试了在具有优先流控制（PFC）的结构上，并且使用OS-bypass消息传递。（这经常被用于FCoE中的低损耗和延迟，例如DCB）RDMA的传输通过NIC，并且对丢包比较敏感。PFC确保了无丢包，因此对RDMA尤其重要。将TIMELY添加到RDMA的设置中，来观察它的好处；检查PFC暂停消息计数是否很低，来确保有足够的交换机缓存来使TIMELY工作。</li>
<li>第二种，使用优化的内核堆栈，在不使用PFC的情况下，运行DCTCP。选择DCTCP，是因为它是一个众所周知的现代数据中心的传输协议。</li>
</ul>
<p>因此，主要做了以下四类的对比实验：</p>
<ol>
<li>使用DCTCP，没有PFC的结构上的内核DCTCP</li>
<li>使用PFC，进行OS-bypass消息传递</li>
<li>使用类似TCP FAST的拥塞控制算法，进行OS-bypass消息传递</li>
<li>使用TIMELY，进行OS-bypass消息传递</li>
</ol>
<h3 id="小规模实验"><a href="#小规模实验" class="headerlink" title="小规模实验"></a>小规模实验</h3><p>小规模实验中，采用incast的模式，这是数据中心最重要的网络拥塞情况。为了创造这样的incast情形，采用10台机器在单一的机架上，同时给一台服务器发送数据。每个client运行4个链接，一共40个链接。这是测试拥塞控制的理想典型网络环境——虽然数据中心存在数以万计的链接，但因为网络被限制的连接数通常很少。</p>
<h4 id="测量的RTT必须精准："><a href="#测量的RTT必须精准：" class="headerlink" title="测量的RTT必须精准："></a>测量的RTT必须精准：</h4><p>为了证明RTT样本准确的重要性，作者在测量RTT中添加噪声，并观察其对吞吐量的影响。将均匀分布的随机噪声添加到每个RTT样本中。图12显示了在不同噪声水平下，总吞吐量的变化。发现噪声越高，性能损失就越严重。 因此，NIC支持的准确RTT测量是TIMELY的基石。<br><img src="/2019/01/20/TIMELY/图12.png" alt=""></p>
<h4 id="与PFC做比较："><a href="#与PFC做比较：" class="headerlink" title="与PFC做比较："></a>与PFC做比较：</h4><p><img src="/2019/01/20/TIMELY/表1.png" alt=""><br>表1比较了使用OS-bypass的TIMELY，和PFC部署的RDMA，图13显示了对四个单独链接，使用TIMELY后，RTT和吞吐量随时间变化的轴线。观察到4个流公平共享带宽，并且RTT维持在较低的水平。为了量化测试带宽分配的公平程度，计算了Jain fairness指数，TIMELY的指标达到0.953，而PFC的指标达到0.909。TIMELY的设计可以做到更公平共享带宽。<br><img src="/2019/01/20/TIMELY/图13.png" alt=""></p>
<h4 id="和DCTCP的对比"><a href="#和DCTCP的对比" class="headerlink" title="和DCTCP的对比"></a>和DCTCP的对比</h4><p>将DCTCP和TIMELY做对比。注意到，必须比较两个不同的主机软件堆栈，因为DCTCP在没有PFC支持的优化内核中运行，而TIMELY用于OS-bypass消息传递。RTT分布如图14所示。TIMELY的平均端到端延迟比DCTCP低10倍（60μs对600μs）。更重要的是，尾部延迟下降了近13倍（116μs对1490μs）<br><img src="/2019/01/20/TIMELY/图14.png" alt=""></p>
<h4 id="和TCP-FAST-like算法做对比"><a href="#和TCP-FAST-like算法做对比" class="headerlink" title="和TCP FAST-like算法做对比"></a>和TCP FAST-like算法做对比</h4><p>作者将TIMELY和TCP-FAST拥塞控制算法作比较。此方法使用TCP-FAST方程来调整pacing速率，而不是周期性地更新拥塞窗口。TCP-FAST可通过协议参数a进行调整，该参数控制带宽的公平性以及网络中的缓冲总量。<br>表1显示三个不同a值下的结果。对于较小的a=10 Mbps，FAST可以实现较低的尾端延迟 49us，尽管吞吐量显着下降。对于较大的a=50 Mbps，TIMELY仍然可以实现较好的的吞吐量和延迟权衡。</p>
<h4 id="变化的Tlow"><a href="#变化的Tlow" class="headerlink" title="变化的Tlow"></a>变化的Tlow</h4><p>TIMELY的性能，也受算法参数的影响，如RTT低阈值Tlow。RTT的变化与最大分段大小相关，随着分段变大，incast时的RTT会增加。图15显示了对于大小为16 KB，32 KB和64 KB的段，瓶颈吞吐量和RTT时间如何随着Tlow的变化而变化。<br><img src="/2019/01/20/TIMELY/图15.png" alt=""></p>
<p>从图中观察到，降低Tlow会降低网络延迟，这是因为较低的阈值，允许更频繁地使用RTT梯度来调整响应队列变化的速率。但是较低的阈值最终会对吞吐量产生负面影响。</p>
<h4 id="使用细粒度的pacer调整使Burst更平滑"><a href="#使用细粒度的pacer调整使Burst更平滑" class="headerlink" title="使用细粒度的pacer调整使Burst更平滑"></a>使用细粒度的pacer调整使Burst更平滑</h4><p>速率控制引擎为段与段之间添加pacing延迟，为了更好适应burst的情况，作者选择采用细粒度pacing。除了主机软件pacing之外，NIC硬件也使用pacing来发送数据包（例如HULL），该规则在Linux内核中已有实现。​图16显示了不同NIC pacing速率的结果。</p>
<p><img src="/2019/01/20/TIMELY/图16.png" alt=""></p>
<p>注意到，在TIMELY设计中，NIC硬件pacing不是绝对的要求;但更确切地说，可以实现在较低的网络尾端延迟和由于软件pacing引起的较高的CPU开销之间权衡。</p>
<h4 id="变化的Thigh"><a href="#变化的Thigh" class="headerlink" title="变化的Thigh"></a>变化的Thigh</h4><p>TIMELY使用一个高阈值，来对更大的RTT来做出更快的反应。这一阈值没有低阈值重要，因为仅对于超大的RTTs起作用。但随着连接变得复杂，RTT突增的可能性变大，这一阈值变得愈发有用。<br><img src="/2019/01/20/TIMELY/图17.png" alt=""><br>​图17显示了不同数量的链路竞争下，这一阈值对吞吐量的影响。在一对四的结构中，99百分位RTT稳定接近200μs。那么，若将Thigh到100us或者更低，RTT会有下降，且吞吐量也非常优异。</p>
<h4 id="激进增量（HAI）"><a href="#激进增量（HAI）" class="headerlink" title="激进增量（HAI）"></a>激进增量（HAI）</h4><p>HAI有助于更快地获取可用带宽。通过多次不同load的incast实验，来证明这一点。incast从10个客户端和每个客户端10个连接开始。在收敛的初始阶段之后，每个客户端同时关闭其10个连接中的9个，从而将剩余连接的公平分享率提高10倍。图18显示了HAI如何在50ms内，将连接吞吐量从初始公平速率200Mbps提升到1.5Gbps，并在100ms内达到2 Gbps的新公平份额。相反，使用固定的加法增量，在140 ms后吞吐量仅仅到1.5 Gbps。发现选择五个连续RTT攻击作为使用HAI的阈值，这一决定，在模型收敛性和稳定性之间取得了良好的平衡。</p>
<h3 id="大规模实验"><a href="#大规模实验" class="headerlink" title="大规模实验"></a>大规模实验</h3><p>通过经典Clos拓扑中的几百台机器上的实验，来研究TIMELY大规模试验。来证明TIMELY能在大型的拥塞网络场景中保持可预测和低延迟。</p>
<h4 id="最长路径均匀随机"><a href="#最长路径均匀随机" class="headerlink" title="最长路径均匀随机"></a>最长路径均匀随机</h4><p>在此流模式中，客户端从具有网络最长路径的一组服务器中选择服务器。客户端发出64 KB请求。服务器回复相应大小的有效负载。客户端计算了RPC延迟（记录了请求发送到服务器到收到服务器响应的时间）。<br><img src="/2019/01/20/TIMELY/图19.png" alt=""><br>图19显示了应用程序在负载增加的情况下，观察到的标准化吞吐量。网络的饱和点（接受负载小于提供的负载的点）对于TIMELY来说更高，因为它能够通过最小化队列，从而也可以每秒暂停帧，来发送更多流量。<br><img src="/2019/01/20/TIMELY/图20.png" alt=""><br>【<br>图20显示了RTT与负载的关系。与PFC相比，TIMELY将RTT的中位数和99百分位数，分别降低了2倍和5倍。这导致RPC中值相应减少约2倍（如图21所示）。如果没有TIMELY，网络队列会增加，以尝试达到提供的负载。有TIMELY，通过将队列从共享网络移到终端主机，来维持低网络队列。因此，随着提供的负载增加超过饱和点，99％的RPC延迟降低效果会减弱。<br>？？？】<br><img src="/2019/01/20/TIMELY/图21.png" alt=""></p>
<h4 id="网络不平衡-incast"><a href="#网络不平衡-incast" class="headerlink" title="网络不平衡(incast)"></a>网络不平衡(incast)</h4><p>为了强调TIMELY缓解拥塞的能力，设计了一个实验，背景负载是最长路径均匀随机流量，使用三个级别的后台负载：低（0.167），中（0.3）和高（0.5）。图22显示了该实验的正常吞吐量和99百分位的RTT。从图19中可知，在网络达到饱和之前，TIMELY和PFC吞吐量对于均匀随机流量是相同的。当添加一个incast，没有TIMELY，吞吐量下降13％至54％，主要原因是由于PFC产生的线路阻塞。用图22中的RTT测量结果也证实了这一观察结果，TIMELY能够保持队列相对较短，并且防止拥塞扩散，且整体吞吐量保持不变。<br><img src="/2019/01/20/TIMELY/图22.png" alt=""></p>
<h4 id="应用级别的标准"><a href="#应用级别的标准" class="headerlink" title="应用级别的标准"></a>应用级别的标准</h4><p>图23显示了数据中心存储的基准测试，RPC延迟（y轴是对数刻度）。有TIMELY的话，该应用程序能够以更高的利用率行动，应用程序数据延迟的下降，这实际上反映了应用程序在查询执行期间能够维持吞吐量的增加。<br><img src="/2019/01/20/TIMELY/图23.png" alt=""></p>
<hr>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>数据中心拥塞控制是一个深入研究的主题。</p>
<p><code>RED</code>和<code>CoDel</code>的方法是通过提前丢弃数据包，促使发送者降低传输速率，以避免与尾部丢弃相关的大型【站点队列？？？】。但是，丢失仍会导致数据包丢失的流量延迟，为了避免数据包丢失，许多方案依赖于ECN形式的交换机支持，其中数据包被标记为指示拥塞。 ECN标记通常在多个数据包上通过组合，提供细粒度的拥塞信息，但作者已经在实验中表明ECN具有固有的局限性。还有其他提议依赖于交换机的支持来缓解拥塞，例如QCN（细粒度队列占用信息）和pFabric（细粒度优先级划分）。</p>
<p><code>TIMELY</code>属于不同类别的算法，使用延迟测量来检测拥塞，且不需要交换机支持。我们从TCP Vegas，FAST和Compound 中获取灵感。这些提议是基于窗口的，并且保持一个接近最小RTT的队列。相比之下，TIMELY是一种基于速率的算法，采用梯度方法，并且不依赖于最小的RTT。实验表明，NIC可以很好的支持TIMELY。</p>
<p>最近的一个方案<code>DX</code>，确定了将延迟用作高吞吐量和低延迟数据中心通信的拥塞信号的好处。DX使用针对NIC的DPDK驱动程序实现准确的延迟测量，并且拥塞控制算法位于Linux TCP协议栈内。DX算法类似于传统的基于窗口的提议，其附加增加和乘法减少与平均队列延迟成比例。</p>
<p>CAIA Delay Gradient（CDG）提出了一种用于广域网的TCP拥塞控制的延迟梯度算法。其主要目标是确定基于延迟与基于损失的拥塞控制是否可以共存。因此，其算法的性质与TIMELY中的算法不同。</p>
<p>链路层流控制，用于Infiniband和数据中心桥接（DCB）网络中的低延迟消息传递。然而，部分论文记录了优先流控制（PFC）的问题，包括HoL阻塞和暂停传播或拥塞扩散。最近的一些提案旨在通过使用ECN标记来维持PFC，维持低队列占用率来克服这些问题。 <code>TCP-Bolt</code>在内核TCP协议栈中使用修改的DCTCP算法。 <code>DCQCN</code> 结合使用ECN标记和在NIC中实现的基于QCN的基于速率的拥塞控制算法。评估表明它解决了PFC的HoL阻塞和不公平问题，从而使RoCE可用于大规模部署。 <code>TIMELY</code>使用RTT信号，在支持NIC时间戳的主机软件中实现，适用于OS-bypass和基于OS的传输。在拥塞控制和CPU利用率方面，TIMELY和DCQCN的比较是一项有趣的未来工作。</p>
<p>拥塞可以通过使用分布式调度方法或集中式调度方法来避免。然而，这些方案尚未大规模证明，并且比简单的基于延迟的方法更复杂。</p>
<p>最后，负载敏感路由（例如<code>Conga</code>和<code>FlowBender</code>）可以通过将网络流向四周扩散，来缓解拥塞的网络拥塞点，从而提高吞吐量。然而，这些方法仍需要基于主机的拥塞控制来提供匹配的负载。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>传统观点认为延迟是数据中心不可靠的拥塞信号。作者设计了TIMELY，发现结果恰恰相反 - 当适当调整延迟后，RTT与网络中的队列建立密切相关。TIMELYd利用现代NIC支持的时间戳和ACK来执行基于精确RTT测量的拥塞控制。TIMELY可以检测并响应数十微秒的队列，以提供低延迟和高吞吐量，即使存在不频繁的RTT信号和NIC offload也是如此。随着数据中心速度向上扩展一个数量级，未来的工作应该集中在RTT如何继续用于拥塞控制，同时重新考虑基于延迟的算法本质。 </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/congestion-control/" rel="tag"># congestion control</a>
          
            <a href="/tags/RDMA/" rel="tag"># RDMA</a>
          
            <a href="/tags/datacenter-transport/" rel="tag"># datacenter transport</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/20/Reproducing-Network/" rel="next" title="Reproducing-Network">
                <i class="fa fa-chevron-left"></i> Reproducing-Network
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/22/ECN-or-DELAY/" rel="prev" title="ECN-or-DELAY">
                ECN-or-DELAY <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="YiqingMa" />
            
              <p class="site-author-name" itemprop="name">YiqingMa</p>
              <p class="site-description motion-element" itemprop="description"><p style="color:MediumSeaGreen;font-size:15px;font-family:Comic Sans MS" > If life deals you lemons, make lemonade. </p></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">65</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/miqianmimi" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:ymaay@connect.ust.hk" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/miqianmimi" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://jacquelinewang.github.io/" title="Jacqueline Wang" target="_blank">Jacqueline Wang</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#摘要："><span class="nav-number">1.</span> <span class="nav-text">摘要：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引入："><span class="nav-number">2.</span> <span class="nav-text">引入：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据中心拥塞指标RTT的值："><span class="nav-number">3.</span> <span class="nav-text">数据中心拥塞指标RTT的值：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RTT直接反应延迟"><span class="nav-number">3.1.</span> <span class="nav-text">RTT直接反应延迟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RTT可以被精确测量"><span class="nav-number">3.2.</span> <span class="nav-text">RTT可以被精确测量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RTT-是一个快速、多位信号："><span class="nav-number">3.3.</span> <span class="nav-text">RTT 是一个快速、多位信号：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RTT-的限制："><span class="nav-number">3.4.</span> <span class="nav-text">RTT 的限制：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIMELY-结构"><span class="nav-number">4.</span> <span class="nav-text">TIMELY 结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RTT的测量"><span class="nav-number">4.1.</span> <span class="nav-text">RTT的测量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#速率计算引擎"><span class="nav-number">4.2.</span> <span class="nav-text">速率计算引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#速率控制引擎"><span class="nav-number">4.3.</span> <span class="nav-text">速率控制引擎</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIMELY-拥塞控制"><span class="nav-number">5.</span> <span class="nav-text">TIMELY 拥塞控制:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#度量和设置"><span class="nav-number">5.1.</span> <span class="nav-text">度量和设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于延迟梯度的策略"><span class="nav-number">5.2.</span> <span class="nav-text">基于延迟梯度的策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心算法"><span class="nav-number">5.3.</span> <span class="nav-text">核心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算延迟的梯度"><span class="nav-number">5.3.1.</span> <span class="nav-text">计算延迟的梯度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算发送速率"><span class="nav-number">5.3.2.</span> <span class="nav-text">计算发送速率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RTT低阈值-Tlow"><span class="nav-number">5.3.3.</span> <span class="nav-text">RTT低阈值-Tlow-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RTT高阈值-Thigh"><span class="nav-number">5.3.4.</span> <span class="nav-text">RTT高阈值-Thigh-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#激进增加HAI-Hyperactive-increase-为了更快的收敛"><span class="nav-number">5.3.5.</span> <span class="nav-text">激进增加HAI(Hyperactive increase)为了更快的收敛</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#梯度-VS-队列大小"><span class="nav-number">5.4.</span> <span class="nav-text">梯度 VS 队列大小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实际应用"><span class="nav-number">6.</span> <span class="nav-text">实际应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传输界面"><span class="nav-number">6.1.</span> <span class="nav-text">传输界面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用NIC完成进行RTT的测量"><span class="nav-number">6.2.</span> <span class="nav-text">使用NIC完成进行RTT的测量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDMA速率控制"><span class="nav-number">6.3.</span> <span class="nav-text">RDMA速率控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用限制行为"><span class="nav-number">6.4.</span> <span class="nav-text">应用限制行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#速率更新频率"><span class="nav-number">6.5.</span> <span class="nav-text">速率更新频率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#额外的调度机会"><span class="nav-number">6.6.</span> <span class="nav-text">额外的调度机会</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#评估"><span class="nav-number">7.</span> <span class="nav-text">评估</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小规模实验"><span class="nav-number">7.1.</span> <span class="nav-text">小规模实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#测量的RTT必须精准："><span class="nav-number">7.1.1.</span> <span class="nav-text">测量的RTT必须精准：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与PFC做比较："><span class="nav-number">7.1.2.</span> <span class="nav-text">与PFC做比较：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#和DCTCP的对比"><span class="nav-number">7.1.3.</span> <span class="nav-text">和DCTCP的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#和TCP-FAST-like算法做对比"><span class="nav-number">7.1.4.</span> <span class="nav-text">和TCP FAST-like算法做对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变化的Tlow"><span class="nav-number">7.1.5.</span> <span class="nav-text">变化的Tlow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用细粒度的pacer调整使Burst更平滑"><span class="nav-number">7.1.6.</span> <span class="nav-text">使用细粒度的pacer调整使Burst更平滑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变化的Thigh"><span class="nav-number">7.1.7.</span> <span class="nav-text">变化的Thigh</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#激进增量（HAI）"><span class="nav-number">7.1.8.</span> <span class="nav-text">激进增量（HAI）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大规模实验"><span class="nav-number">7.2.</span> <span class="nav-text">大规模实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最长路径均匀随机"><span class="nav-number">7.2.1.</span> <span class="nav-text">最长路径均匀随机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络不平衡-incast"><span class="nav-number">7.2.2.</span> <span class="nav-text">网络不平衡(incast)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用级别的标准"><span class="nav-number">7.2.3.</span> <span class="nav-text">应用级别的标准</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关工作"><span class="nav-number">8.</span> <span class="nav-text">相关工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YiqingMa</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>



<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500670004");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>






        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("0ixKT2BwaVfXNDSkwyzUoHme-gzGzoHsz", "EdAY2rFqeW0COVKGLhLtLEAp");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
